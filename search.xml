<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[软考（二）：操作系统]]></title>
    <url>%2Fsoftexam-002-os.html</url>
    <content type="text"><![CDATA[记录操作系统中知识点 @toc ## 考点 进程 进程的基本概念以及状态变化 进程死锁 进程同步、复制，信号量，前趋图，PV原语 存储 其他细节 进程 * 就绪状态：进程已得到运行所需资源，只等待CPU的调度便可运行； * 运行状态：进程已得到运行所需资源，并且得到了CPU的调度； * 等待状态：不具备运行条件、等待时机的状态。另：等待状态也称阻塞状态； * 挂起：把该进程从内存中搬到外存上。 * 激活：又叫唤醒或恢复，操作是一样的，只是叫法不一样而已，该操作是把外存上的某个进程弄到内存上。 为什么要引入挂起和激活操作呢？ 用户的需要。用户调试一个程序的时候，运行该程序一多半了，但是，忽然发现该程序此时有Bug，用户想停下来修改，但是修改后，用户又不想从头开始运行该程序，此为一因。 操作系统的需要。操作系统管理着资源的分配，它无法忍受那些占着资源而不运行的程序，另外，这些进程也会妨碍系统的运行速度，此为一因。等等。 进程的死锁 进程管理师操作系统的核心，但如果设计不当，就会出现死锁的问题。如果一个进程在等待一个不可能发生的事，则进程就死锁了。而如果一个或多个进程产生死锁，就会造成系统死锁 例如：系统有3个进程：A、B、C。这三个进程都需要5个系统资源。如果系统有13个资源，则不可能发生死锁。 死锁发生的必要条件 互斥条件：即一个资源每次只能被一个进程使用，在操作系统中这是真实存在的情况。 保持和等待条件：有一个进程已经获得了一些资源，但因请求其他资源被阻塞时，对已获取的资源保持不放。 不剥夺条件：有些系统不可资源是不可剥夺的，当某个进程已获得这种资源后，系统不能强行收回，只能由进程使用完时自己释放。 环路等待条件：若干个进程形成环形链，每个都占用对方要申请的下一个资源。 解决死锁的策略 死锁预防：例如：要求用户申请资源时一起申请所需的全部资源，这就破坏了保持和等待条件；将资源分层，得到上一层资源后，才能够申请下一层资源，它破坏了环路等待条件。预防通常会降低系统的效率。 死锁避免：避免是指进程在每次申请资源时判断这些操作是否安全，典型算法是「银行家算法」。但这种算法会增加系统的开销。 死锁检测： 死锁解除 银行家算法 著名的银行家算法，最早是由Dijkstra提出来的。它是一种最有代表性的避免死锁的算法。在避免死锁方法中允许进程动态地申请资源，但系资源分配之前，应先计算此次分配资源的安全性，若分配不会导致系统进入不安全状态，则分配，否则等待。 银行家算法最重要的就是判断是可用资源和仍需资源之间的关系，如果可用资源数大于人需资源数，那么我们认为这个进程就是可以执行的，也是安全的，反之，便是不安全的。所以重中之重的是找到各种资源数。 对进程的判断遵循以下步骤: 1. 计算系统开始时所有的资源数,即开始的可用资源数; 2. 在仍需资源数和可用资源数中作比较,找到符合条件的进程,最后修改进程执行完毕时系统的可用资源数; 3. 继续比较剩余进程和可用资源数,找到下边可以执行的进程; 4. 依次类推; 【例】假设系统中有3类互斥资源R1、R2、R3，可用资源分别是9、8、5,。在T0时刻系统中有P1、P2、P3、P4和P5五个进程，这些进程对资源的最大需求量和已分配资源数如下表所示，则进程如何执行是安全的。 这里需要强调的是，无论题目中给出何种条件，我们只要找到以下信息便可从容应对各种变化： 【注】： 可用资源：表示相应的进程执行完毕（即释放该进程占用的资源）以后可用的资源，满足公式可用资源=可用资源+已分配资源，（因为已分配的资源将会在进程执行完毕以后释放，所以可用资源会不断增多，进程执行完毕便会全部释放）同时它也是下一个进程执行时可用的资源。 **需要说明的是根据进程执行情况的不同，每次填入表格中的可用资源也不会相同（因为每个进程分配的资源是有差异的），那么执行顺序也会有所差异，合理即可。 仍需资源：仍需资源数=最大需求量-已分配资源数，据此公式可以求得R1、R2、R3在不同的进程时仍需的资源数，如上表中所示。 按照之前所讲的步骤，实现如下： 开始有的资源数R1 R2R3分别为2、1、0,所以从仍需资源中查找(需要说明的是查找的时候以最少资源数作为限定条件能够较快地找出结果),只有P2进程符合条件,此时可用资源变为4、2、1； 接下来在在其余的进程中查找符合条件的进程,只能执行P4,此时可用资源变为5、4、1,以此类推,按照以上的步骤即可找到所有进程执行的顺序P2-&gt;P4-&gt;P5-&gt;P1-&gt;P3； 以上便是有关银行家算法的计算过程。 前趋图 前趋图（Precedence Graph）是一个有向无循环图，记为DAG（Directed Acyclic Graph），用于描述进程之间执行的前后关系。途中的每个节点可用于描述一个程序段或进城，乃至一条语句；节点间的有向边则用于表示两个节点之间存在的偏序（Partial Order）或前驱关系（Precedence Relation）「→」]]></content>
      <tags>
        <tag>软考</tag>
        <tag>编译原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软考（一）：文法]]></title>
    <url>%2Fsoftexam-001-grammar.html</url>
    <content type="text"><![CDATA[记录编译原理中文法的知识点 编译原理顾名思义就是处理高级语言，使之称为计算机能够识别的语言（低级语言）的原理。而文法呢？就是用来描述程序设计语言的方法。类似佛法,用来描述佛家的诵经禅道的规则的。 @toc 概念 正如英语是由句子组成的集合，而句子又是由单词和标点符号组成的序列那样。程序设计语言 C 语言，是由 C 程序所组成的集合，而程序是由类似 if , begin, end 的符号，字母和数字这样一些基本符号所组成。 从字面上看，每个程序都是一个“基本符号”串，设有一基本符号串，那么 C 语言可看成是在这个基本符号集上定义的，按一定规则构成的一切基本符号串组成的集合。 通俗的讲就是：根据一些指定的规则，来确定编程语言的语法，从而实现编译器的功能。 终结符和非终结符 文法是由非终结符（大写字母）和终结符（小写字母）以及“—&gt;”组成的。 通过上面的几个例子可以看出：非终结符A、B、S，一般是写在左边，而终结符a、dba、b，一般是写在右边的。当然习惯的写法是非终结符用S（Start）表示，写在左边，自然而然的小写的就在右边了，这样也便于我们记忆文法的表示方式。 如上所示：在这个推导式的集合中，存在六个推导式。其中S、A、B为非终结符。a、b、c、d、q、p为终结符。终结符是原子不可分的。 分类 在1956年的春天，一个叫乔姆斯基(Chomsky)的人发明了上述文法，他觉得有些文法存在着相似的形式，于是他就给文法分了一下类。 首先有一个前提：设有一个组合G=(Vn,Vt,P,S)。其中Vn是非终结符的集合，Vt是终结符的集合，P是推导式的一个集合，S是开始符。就上面的例子来说，A、B、S是Vn，a、dba、b是Vt，整个的集合为P。 0型文法 这是最简单的一个文法。它比较宽容，没有那么多的限制条件。左边必须要包含这些元素或者元素组合中的至少一个非终结符，右边可以是这些元素的任意组合，这样就构成了0型文法。由于限制最少，所以见到的文法至少是一个0型文法。如： 1型文法（上下文有关文法） 1型文法也叫上下文有关文法，此文法对应于线性有界自动机。 它在0型文法的基础之上，只添加了一个要求：右边的长度&gt;=左边的长度（终结符或非终结符的个数）。A—&gt; a、B—&gt;dba则是1型文法，而adB—&gt;d不符合1型文法要求 注意这里有一个特殊的形式 S—&gt; ∑（∑表示空），也是一个1型文法。 2型文法（上下文无关文法） 2型文法也叫上下文有关文法，此文法对应于下推自动机自动机。 它在1型文法的基础上，有增加了一个要求：左边必须是非终结符（个数不限）。 如：AB—&gt;de 属于2型文法，而 Aa—&gt;DE则不是，因为Aa中含有a。 3型文法（正规文法） 3型文法也叫正规文法，它对应有限状态自动机。 它是在2型的基础上提出了要么一个非终结符推出一个终结符，要么一个非终结符推出一个终结符并且带一个非终结符。 A-&gt;a | aB（右线性）或 A-&gt;a | Ba（左线性） 而上面的左线性、右线性是相互独立的。如：A—&gt;b、A—&gt;bD这是3型文法 但是A—&gt;b、A—&gt;bD、A—&gt;Db则不是3型文法。从这里可以看出，对于3型文法，它不是左右线性的“组合”，要么都是右线性，要么都是左线性。 三种文法关系 \[ 3\text{型文法} \subset2\text{型文法} \subset1\text{型文法} \subset0\text{型文法} \] 正规式 item 文法产生式 正规式 规则1 \[A-&gt;xB,B-&gt;y\] \[A=xy\] 规则2 \[A-&gt;xA\vert y\] \[A=x^*y\] 规则3 \[A-&gt;x,A-&gt;y\] \[A=x\vert y\] 实例 实例1 \[ A-&gt;\varepsilon|aB,B-&gt;Ab|a \] &gt; 判断上面推导式中满足什么类型的文法 首先要判断哪些是==终结符和非终结符==,简单来讲终结符就是终结的,最小的不可拆分的元素,而不是终结符的都是非终结符.这个应该是没有任何问题的,所以上题中,的非终结符就是AB,其他都是非终结符.而0型文法中,讲到只需要在p中至少有一个非终结符,也就是在推导式的左边至少存在一个非终结符就可以了.这样一来,我们看到在等式的左边,两个都是非终结符.肯定满足0型文法,下面就是1型文法了,1型文法是怎么规定的呢?在0型文法的基础上,推导式的==左边的长度肯定小于或者等于右边的长度==,题中p集合里面左边的长度都小于右边的长度,所以肯定符合1型文法;接下来就是看看是否满足2型文法了.2型文法是怎么来限定的呢？在1型文法的基础上，在推导式的==左边每个都是非终结符==，如题，每个推导式的左边都是非终结符，所以肯定是2型文法了；3型文法的意思就是2型文法的基础上，看看是否满足右线性或者左线性，我们将这个推导式分开来判断。A–&gt;a或者A—&gt;aB，第一个拆开的推导式是右线性，而B—&gt;A是左线性的，3型文法是怎么规定的呢？是符合==左线性或者右线性==。 实例2 \[ \begin{align*} &amp;\mbox{文法}: G: S-&gt;xSx | y\mbox{所识别的语言是}（）。\\ &amp;A. xyx\\ &amp;B. (xyz)^*\\ &amp;C. x^*yx^*\\ &amp;D. x^nyx^n(n\geq0)\\ \end{align*} \] 解析：D。 \[S-&gt;xSx-&gt;xxSxx-&gt;x…S…x-&gt;x…y...x-&gt;x^nyx^n\] 因为S-&gt;y，所以 n 可以为0，即 n 的范围为大于等于0。 ### 实例3 解析：C。A-&gt;bA-&gt;bca。第二次替换A的时候，使用候选式A-&gt;ca 即可。 实例4 \[ \begin{gather} &amp;\text{对于一下编号为①，②，③的正则式，正确的说法是___。}\\ &amp;\text{①}(aa^*|ab)^b \qquad\qquad\qquad \text{②}(a|b)^b \qquad\qquad\qquad \text{③}((a|b)^*|aa)^b \\ \qquad \\ &amp;A. \text{正则式①，②等价} \qquad B. \text{正则式①，③等价}\\ &amp;C. \text{正则式②，③等价} \qquad D. \text{正则式①，②，③互不等价} \end{gather} \] 解析：C。①中任意个前始终有b，②中为任意个a或b，故①②不等价，③中包含②并且任意长度a和故b组成的串，aa限制条件不是必要条件故②③等价。 实例5 \[ \begin{gather} &amp;\text{语言}L=\{a^mb^n|m\geq0,n\geq1\} \text{的正规表达式是_____。}\\ &amp;\begin{matrix} A. a^*bb^* &amp; B. aa^*bb^* &amp; C. aa^*b^* &amp; D. a^*b^* \end{matrix} \end{gather} \] 解析：A。a^代表若干个a包括零个a，\(b^b\)表示至少一个b。]]></content>
      <tags>
        <tag>软考</tag>
        <tag>编译原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fhello-world.html</url>
    <content type="text"><![CDATA[github + hexo + NexT Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post More info: Writing Run server More info: Server Generate static files More info: Generating Deploy to remote sites More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[Scrapy-cluster分布式爬虫]]></title>
    <url>%2Fpython-001-scrapy-cluster.html</url>
    <content type="text"><![CDATA[记录搭建scrapy-cluster以及管理工具scrapyd+spiderkeeper 基于Scrapy-cluster库的kafka-monitor可以实现分布式爬虫 Scrapyd+Spiderkeeper实现爬虫的可视化管理 环境 IP Role 168.*.*.118 Scrapy-cluster,scrapyd,spiderkeeper 168.*.*.119 Scrapy-cluster,scrapyd,kafka,redis,zookeeper Zookeeper 单机配置 下载并配置 单节点启动 kafka 单机配置 下载 配置 启动 停止命令bin/kafka-server-stop.sh config/server.properties redis 单机配置 安装配置 启动 scrapy-cluster 单机配置 离线运行单元测试,以确保一切似乎正常 修改配置 修改以下 启动监听 scrapyd 爬虫管理工具配置 安装 配置 启动 建议做Nginx反向代理 启动异常 解决：Automat降级 Spiderkeeper 爬虫管理界面配置 安装 启动 浏览器访问http://168...118:5000 使用Spiderkeeper 管理爬虫 使用scrapyd-deploy部署爬虫项目 修改scrapy.cfg配置 添加新的spider 使用scrapyd-deploy部署项目 spiderkeeper 配置爬虫项目 登录Spiderkeeper创建项目 使用scrapy.cfg中配置的项目名 创建后再Spiders-&gt;Dashboard中看到所有spider Scrapy-cluster 分布式爬虫 Scrapy Cluster需要在不同的爬虫服务器之间进行协调，以确保最大的内容吞吐量，同时控制集群服务器爬取网站的速度。 Scrapy Cluster提供了两种主要策略来控制爬虫对不同域名的攻击速度。这由爬虫的类型与IP地址确定，但他们都作用于不同的域名队列。 Scrapy-cluster分布式爬虫，分发网址是基于IP地址。在不同的机器上启动集群，不同服务器上的每个爬虫去除队列中的所有链接。 部署集群中第二个scrapy-cluster 配置一台新的服务器参照scrapy-cluster 单机配置,同时使用第一台服务器配置kafka-monitor/settings.py redis-monitor/settings.py crawling/settings.py Current public ip 问题 由于两台服务器同时部署在相同内网，spider运行后即获取相同Current public ip，导致scrapy-cluster调度器无法根据IP分发链接 参考代码/root/scrapy-cluster/crawler/crawling/distributed_scheduler.py第282行： 建议修改代码，获取本机IP 运行分布式爬虫 在两个scrapy-cluster中运行相同Spider 使用python kafka_monitor.py feed投递多个链接，使用DEBUG即可观察到链接分配情况 使用SpiderKeeper管理分布式爬虫 配置scrapyd管理集群第二个scrapy-cluster 在第二台scrapy-cluster服务器上安装配置scrapyd，参考scrapyd 爬虫管理工具配置并修改配置 启动scrapyd后使用scrapyd-deploy工具部署两个scrapy-cluster上的爬虫项目。 使用Spiderkeeper连接多个scrapy-cluster 重新启动spiderkeeper，对接两个scrapy-cluster的管理工具scrapyd。 注意：要使用spiderkeeper管理同一个集群，爬虫项目名称必须一致，同时集群中scrapy-cluster配置相同spider任务 浏览器访问http://168...118:5000 启动爬虫时即可看见两个scrapy-cluster集群配置，启动同名爬虫开始scrapy-cluster分布式爬虫 启动分布式爬虫后状态]]></content>
  </entry>
</search>
